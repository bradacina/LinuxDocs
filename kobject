
KObject
-------

linux/kobject.h

#define KOBJ_NAME_LEN 20

struct kobject {
	char *k_name;
	char                    name[KOBJ_NAME_LEN];
    struct kref             kref;
    struct list_head        entry;
    struct kobject          *parent;
    struct kset             *kset;
    struct kobj_type        *ktype;
    struct dentry           *dentry;
};

Every kobject must have a name (not NULL). It's either a char array of size 20 or it ponints to a string obtained from kmalloc().
Don't forget to kfree() the string when done.

A kobject can be member of a kset set in the field kobj->kset. The kset must be set before we cann kobject_init().

A kobject is reference counted. The routines kobject_get() and kobject_put() do get/put on the kref field. When the reference
count goes to 0 a kobject_cleanup() is done.

Most fields of kobject are not touched by kobject_init(). One should memset the kobject to zero and possibly assign kset before
calling kobject_init().

A kobject can appear in sysfs. It is added with kobject_add() and deleted with kobject_delete().

NOTE: sysfs_create_dir() - creats a new directory below the root /sys

struct kobject *ko;

int kobject_set_name(ko, char *, ...)
char *kobject_name(ko)
void kobject_init(ko)
struct kobject *kobject_get(ko)
void kobject_put(ko)
void kobject_cleanup(ko)
int kobject_add(ko)
void kobject_del(ko)
int kobject_register(ko) /* kobject_init() + kobject_add() */
void kobject_unregister(ko) /* kobject_del() + kobject_put() */
int kobject_rename(ko, char *new_name)
void kobject_hotplug(const char *action, ko)
char *kobject_get_path(struct kset *, ko, int)


A kobject is usualy embeded by other structures. The container_of() method is used to retrieve the embeding structure. 
Don't forget to kfree() the embeding struct.

Kobject is linked to other kobjects through its kparent member. If not, the Kobject
must be part of a kset.

Ksets
-----

struct kset {
        struct subsystem        *subsys;
        struct kobj_type        *ktype;
        struct list_head        list;
        struct kobject          kobj;
        struct kset_hotplug_ops *hotplug_ops;
};

Ksets are containers of kobject. Ksets must have a ktype. A kset contains its own
internal kobject. When adding a kobject to a kset, we must set the kset member of the
kobject and then call:

	int kobject_add(struct kobject *kobj);

This can return a negative value if it fails. To remove it from the kset we call:

	void kobject_del(struct kobject *kobj);

There are utility functions to help with kinit and kadd:

	extern int kobject_register(struct kobject *kobj);

and kdel and kput:
	kobject_unregister(struct kobject *kobj);

The field list provides a circularly linked list of the kobjects that are members of the kset. All kobjects on the list have a kset
field that point back to us. In order to examine or manipulate the list one needs to hold the kset->subsys->rwsem semaphore.

struct kset *ks

void kset_init(ks)
struct kset *to_kset(ko) /* converts a pointer to the kobject field of a kset into a pointer to the kset itself */
struct kset *kset_get(ks)
void kset_put(ks)
int kset_add(ks)
int kset_register(ks)
void kset_unregister(ks)
struct kobject *kset_find_obj(ks, char *) /* finds the kobject with the given name in the kset */

KType or KObject_Type
---------------------

struct kobj_type {
	void (*release)(struct kobject *);
	struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
}

A kobject must point to a kobj_type ( this defines the type of kobject ). If the kobject
is part of a kset, the kset must point to a kobj_type. 

The following macro finds the type of a kobject:

	struct kobj_type *get_ktype(struct kobject *kobj);

The attributes describe ordinary file in the sysfs tree. It's a NULL terminated list of:

struct attribute {
        char                    *name;
        struct module           *owner;
        mode_t                  mode;
};

The contents of these files is generated by show() and can possibly be modified by the store() function:
struct sysfs_ops {
        ssize_t (*show)(kobj, struct attribute *attr, char *buf);
        ssize_t (*store)(kobj, struct attribute *attr, const char *, size_t);
};

Code in Linux kernel seems to use the __ATTR macro to create struct 
kobj_attribute. This struct has a field called .attr of type struct attribute
that is used when initializing the kobj_type.default_attrs field.

Code in Linux kernel is using kobj_sysfs_ops for the sysfs_ops field of the
kobj_type. The kobj_sysfs_ops comes precoded with store and show methods that
will get the container_of the attribute (yielding kobj_attribute) and will
forward the calls to store and show to the store and show defined in the 
kobj_attribute struct.

The pattern to initialize a ktype seems to be:
struct kobj_attribute myAttr = __ATTR(name, mode, show, store);
struct attribute attributes[] = { &myAttr.attr, NULL }; 
struct kobj_type type = { .sysfs_ops = &kobj_sysfs_ops, .default_attrs = attributes };
